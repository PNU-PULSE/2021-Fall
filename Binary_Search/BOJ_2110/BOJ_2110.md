## 이분 탐색 (Binary Search)
### BOJ 2110번   <https://www.acmicpc.net/problem/2110>
<hr/>   

 
### (1) 문제 ###   

> 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
> **C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는** 프로그램을 작성하시오.

* 입력  

첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.  

* 출력  

첫째 줄에 **가장 인접한 두 공유기 사이의 최대 거리**를 출력한다.<br>
<hr/>

### (2) 처음에 문제를 틀린 이유 ###  

1. 문제를 제대로 이해하지 못함<br><br>
2. 이진 탐색 대상을 제대로 설정하지 못함   
	집(N)의 개수는 최대 200,000개라서 괜찮지만, 집의 좌표는 최대 1,000,000,000(10<sup>9</sup>)이라서 모든 경우를 다 탐색할 경우 시간 초과가 발생한다.  
	이진 탐색(O(log<sub>2</sub>n)을 사용해 탐색할 데이터 수를 줄이고, 최악의 경우에도 30번의 탐색만 하면 된다는 것까지는 이해했다.   
  	하지만 '어떤 것, 어떤 값'을 이진 탐색의 대상으로 정해야 하는지 어려웠고 다양하게 시도해봤다.  <hr/>
  
   
   
### (3) 오답 해결 방법 ###  

1. 모든 경우 (= 최대 거리)를 다 따지면 최대 X<sub>i</sub>는 1,000,000,000이므로 최대 거리차가 (1,000,000,000 - 1)이 된다. 그러므로 이 문제에는 이진 탐색을 사용해야 한다.<br><br>
2. 처음에는 당연히 집의 좌표 (X<sub>i</sub>)를 탐색 대상으로 생각했다. <br> **하지만 이 문제는 '공유기가 설치된 두 집의 거리 차'의 최솟값과 최댓값을 
   각각 이분탐색의 left, right값으로 정해야 하고, 이 둘의 평균을 mid 값으로 해야 한다.**<br><br>
   
3. 또 처음에는 공유기 개수(C)에 딱 맞게 구해야 된다고 생각했는데 (공유기 개수 C개를 설치하면 탐색을 종료한다고 생각했음)   
      다른 풀이들을 보니 이 문제는 공유기 개수 C에 딱 맞게 구하는 게 초점이 아니라, **가장 인접한 두 공유기 사이의 최대 거리**를 구하는 것이  
      포인트이므로 그냥 공유기 위치를 C개 이상을 찾았으면 그냥 '최대 거리'를 구할 수 있는지 계속 찾아보면 된다.<br><hr/>

### (4) 소스 코드 ###  


```
int BinarySearch(int left, int right) {				
	int Max = 0;			// 이분 탐색을 반복 하면서 '거리차가 가장 큰 값'을 반환하기 위해 계속해서 갱신된다.					

	while (left <= right) {	
        int count = 1;					 //  무조건 입력받는 좌표 값 중 제일 작은 값을 가지는 좌표(집)에 공유기가 설치되는 것으로 생각한다. 
		int mid = (left + right) / 2;
		int available_from_this = location[0];	 //  입력받는 좌표 값 중 제일 작은 값을 가지는 좌표(집)에 공유기가 설치된다. 

		for (int i = 0; i < N; i++) {
			if (available_from_this + mid <= location[i]) {
				available_from_this = location[i];
				count++;
			}
		}
		if (count >= C) {		
			left = mid + 1;
			Max = mid;		
		}
		else {
			right = mid - 1;
		}
	}
	return Max;
}
```

```
int mid = (left + right) / 2;
```

1. 거리 차 ==  mid (거리차 평균) ==  [(left(최소 거리차) + right(최대 거리차)) / 2 ]
결국,  '거리 차'를 늘리거나 줄이는 것은
left, right를 조절하는 것<br><br>

```
int available_from_this = location[0];
```
2. 왜 다음 번 이분탐색 시 또 처음 (location[0])부터 다시 조사해햐하는가 이해가 안갔었다.
but, 거리 차(mid)를 늘리거나, 줄였을 때(=mid값을 조절했을 때) 공유기를 C개 이상 설치할 수 있는 경우를 찾기 위해
맨 처음 좌표부터 다시 보는 것이었다..!<br><br><br>

```
if (available_from_this + mid <= location[i]) {
	available_from_this = location[i];
	count++;
}
```

3. (available_from_this + mid)와 location[i]이   
**값이 같다면** 시작점(available_from_this)으로부터 mid만큼 떨어져 있다는 뜻이고<br>
**값이 크다면** 시작점으로부터 mid보다 더 멀리 떨어져 있다는 뜻   ☞ 많이 떨어져 있을수록 더 좋음<br>
**값이 작다면** 시작점으로부터 mid만큼 떨어진 곳에 집이 없어서 공유기를 설치할 수 없다는 뜻
그러므로 '값이 같거나 큰 경우'는 시작점(available_from_this)을 갱신해서 더 가능한 경우가 있는지 탐색한다<br>
시작점(available_from_this)을 갱신하는게 굉장히 중요하다<br>
왜냐하면 '시작점(available_from_this)'은 (처음) 조건을 만족한 집(좌표)이다.<br>
그러므로 시작점 이하에 위치한 집 (좌표) ==> 조건이 안맞거나 이미 조건을 만족한 집<br>
따라서 시작점 이상의 위치에 조건을 만족하는 집(좌표)가 있는지 찾기 위해 시작점 갱신 필요<br><br><br>



```
if (count >= C) {		// 최소 거리차(left)를 증가시킴	
	left = mid + 1;
	Max = mid;		//  이때까지의 최대 거리차 mid를 저장 (이후 갱신 가능)
	cout << "\nmax : " << Max << endl;
}
```
4. 공유기 개수 C만큼 위치를 다 찾았으면
'최대 거리 차'를 구하기 위해 '거리 차'를 늘려가며 가능한 경우를 탐색한다.<br><br><br>


```
else {		// 최대 거리차(right)를 감소시킴
	right = mid - 1;
}
```
5. 공유기 개수 C만큼 위치를 다 찾지 못했다면
'거리 차'를 줄여가며 공유기 개수만큼 설치부터 한다.<br><br>

<hr/>



```
int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr);
        
	int L, R;
    
	cin >> N >> C;
	
	if (N < 2)		
		return 0;   

	for (int i = 0; i < N; i++) {
		cin >> location[i];
	}

	sort(location, location + N);
	
	L = 1;						// 최소 거리 차는 1이다. (바로 옆에 집이 있는 경우를 떠올리면 된다.)
	R = location[N - 1] - location[0];		// 최대 거리 차는 (맨 마지막 집(좌표) - 맨 처음 집(좌표))
	

	cout << BinarySearch(L, R);			// 이진 탐색의 대상 == 거리 차 (L:최소 거리차, R:최대 거리차) 
							// (집의 좌표가 아니다!) 
	return 0;
}
```
