# BOJ 1365

![예시 이미지](https://github.com/PNU-PULSE/2021-Fall/blob/main/Binary_Search/BOJ_1365/1.png)
===========
문제에서 입력으로 올 수 있는 상황은 다음과 같다.

![예시 이미지](https://github.com/PNU-PULSE/2021-Fall/blob/main/Binary_Search/BOJ_1365/2.png)

위 2가지 상황에서 전깃줄이 꼬이지 않게 하려면 4-1과 1-4의 연결을 잘라내야한다. <br>
그리고 그러고 나면 남은 전깃줄은 (2,3,4), (1,2,3) 이다. <br>

이 두 가지 상황에서 알 수 있는 점은 점은 전깃줄이 큰 수에서 작은 수로 연결되던지, 작은 수에서 큰 수로 연결되던지 <br>
남은 전깃줄은 항상 증가하는 수열로 구성되어 있다는 것이다. <br>

즉, 최장 길이 증가하는 수열을 찾는 것이 최소한의 꼬인 전깃줄을 제거하고 나면 몇 개의 전깃줄이 남는지 알 수 있게 해준다. <br>
===========

#### 그렇다면 최장 길이 수열은 어떻게 구할 수 있을까?

예를 들어, 배열 A  [ 3, 5, 7, 9, 2, 1, 4, 8]가 있다고 하자<br>
A에서 최장 길이 증가하는 수열을 찾는다면 그 방식은 의외로 간단하다 <br>

배열 V = [-1]를 하나 마련하고 A의 i번째 원소가 A[i]라고 A의 크기를 N이라고 하자 <br> 

i = 0부터 N-1까지 증가시키면서 A[i]가 V의 마지막 원소보다 크면, V에 A[i]를 추가하고 </br>
A[i]가 V의 마지막 원소보다 같거나 크면, V의 원소들 중 A[i]보다 큰 원소들 중에 가장 작은 원소, 즉 lower bound와 A[i]를 교환한다 </br>
그리고 이 과정을 i = N -1까지 반복하면 최장 길이 증가하는 배열의 크기는 바로 V의 크기 - 1 이 된다 </br>

A에서 최장 길이 증가하는 수열을 찾는 과정을 표로 나타내면 다음과 같다.</br>

#### 초기 상태 
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 |  |  |  |  |  |  |  |  |


#### i = 0
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 3 |  |  |  |  |  |  |  |

#### i = 1
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 3 | 5 |  |  |  |  |  |  |

#### i = 2
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 3 | 5 | 7 |  |  |  |  |  |

#### i = 3
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 3 | 5 | 7 | 9 |  |  |  |  |

#### i = 4
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 2 | 5 | 7 | 9 |  |  |  |  |

#### i = 5
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 1 | 5 | 7 | 9 |  |  |  |  |


#### i = 6
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 1 | 4 | 7 | 9 |  |  |  |  |

#### i = 7
index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
 ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
A | - | 3 | 5 | 7 | 9 | 2 | 1 | 4 | 8
V | -1 | 1 | 4 | 7 | 8 |  |  |  |  |

따라서 V의 크기 5 - 1 = 4가 최장 길이 증가하는 수열의 크기다. </br>
물론 V가 가지고 있는 원소들은 최장 길이의 증가하는 수열의 값은 아니므로 수열을 알기 위해서는 추가적인 배열을 사용해야 한다.
```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	int n, target, cnt = 0;
	cin >> n;
	vector<int> vec(n + 1);
	vec[0] = -1;
	for (int i = 0; i < n; ++i) {
		cin >> target;
		if (vec[cnt] < target)
			vec[++cnt] = target;
		else {
			vec[lower_bound(vec.begin(), vec.begin() + cnt, target) - vec.begin()] = target;
		}
	}

	cout << n - cnt;

	return 0;
}
```
