## 다이나믹 프로그래밍 (Dynamic Programming) 
### BOJ 4811 - 알약      <https://www.acmicpc.net/problem/4811>

<br>

### (1) 문제 ###
![문제](https://user-images.githubusercontent.com/83392219/141604509-1055a5b8-e81e-48db-a36d-3e815e3d2ebe.JPG)

<br>

### (2) 풀이 ###

문제에서..
> 다음 날부터 종수는 병에서 약을 하나 꺼낸다. (약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고, 아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다.  

라고 했으므로 약을 먹는 경우는 2가지이다. 약을 골랐는데 약이 완전한 한 알이거나, 반으로 쪼개져있거나. <br>
따라서 한 알을 (쪼개어) 먹으면 --> 한 알 1 감소, 반 알 1 증가 (반 알 2증가가 아닌 이유는 한 쪽을 먹기 때문) <br>
쪼개져 있는 반 알을 먹으면 --> 한 알 변동 없음, 반 알 1 감소 <br><br>


1. DP[온전한 알약 개수][반으로 쪼개진 알약 개수]<br><br>
2. ex) DP[0][1], DP[0][2], DP[0][3], DP[0][4]...와 같이 반으로 쪼개진 알약만 존재한다면 경우의 수는 1가지이다.
   왜냐하면 약을 쪼갤 필요 없이 그냥 반 알을 계속 먹기만 하면 되니까! <br><br>
3. ex) DP[2][0] = DP[1][1], DP[3][0] = DP[2][1]로 바꿀 수 있다. 왜냐하면 반으로 쪼개진 약이 없으면 무조건 한 알을 반으로 쪼개야 하므로 한 알 감소 반 알 증가 <br><br>
4. ex) DP[3][2] = DP[3][1] + DP[2][3]으로 바꿀 수 있다. (한 알을 반으로 쪼개 먹는 경우의 수 + 그냥 반 알을 먹는 경우의 수) 


<br>

### (3) 문제 풀면서 생긴 오류 ###
1. 처음에 문제를 재귀적으로 풀어서 숫자가 조금이라도 커지면 값이 출력이 되지 않는 상황이 벌어졌다. <br><br>
2. 그래서 앞의 값을 저장해 사용하는 메모이제이션 방법으로 코드를 수정했는데, 이 문제의 메모이제이션을 1차원 배열에 할 지, 2차원 배열로 할 지
   감이 잡히지 않았다. 그래서 계속 1차원을 고집하다가 문제가 안풀려 2차원으로 수정했다. 



<br>

### (4) 코드 ###

```csharp
#include <iostream>
using namespace std;

long long DP[31][31];

int main() {
	for (int i = 0; i < 31; i++) {
		for (int j = 0; j < 31; j++) {
			if (i == 0)
				DP[i][j] = 1;
			else if (i != 0 && j == 0)
				DP[i][j] = DP[i - 1][1];
			else
				DP[i][j] = DP[i - 1][j + 1] + DP[i][j - 1];
		}
	}

	while (1) {
		int n;	cin >> n;
		if (n == 0) break;
		cout << DP[n][0] << "\n";
	}

	return 0;
}
```
<br><br>
<b> 재귀 함수로 구현해 에러가 발생한 코드 </b>

```csharp
int find(int f, int s);

int main() {
	while (1) {
		int n;	cin >> n;
		if (n == 0) break;
		cout << find(n, 0) << "\n";
}

int find(int f, int s) {
	if (f == 0 && s != 0)
		return 1;
	if (f != 0 && s == 0)
		return find(f - 1, 1);
	return find(f - 1, s + 1) + find(f, s - 1);
}
```
