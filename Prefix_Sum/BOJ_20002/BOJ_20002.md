## 누적합 (Prefix Sum) 
### BOJ 20002 - 사과나무      <https://www.acmicpc.net/problem/20002>


### (1) 문제 ###
> N × N 크기의 정사각형 모양 과수원이 있고, N × N 개의 사과나무가 1 × 1 크기의 간격으로 모든 칸에 심어져있다.
> 농부 형곤이가 가을을 맞아 사과를 수확하려는데, 땅주인 신영이가 "너는 과수원 내에 사과나무를 **K × K 의 크기의 정사각형 모양으로만 수확해 가져갈 수 있어,** 
> 이때 K는 1보다 크거나 같고 N보다 작거나 같은 정수라구!"라고 통보했다.
> 형곤이는 **총이익을 2차원 배열의 형태**로 정리했다.
> 형곤이에게 **최대 총이익**을 안겨주고 싶은 당신, 형곤이를 도와주자!

* 입력
	첫 번째 줄에는 과수원의 크기 N이 주어진다. (1 ≤ N ≤ 300)
	두 번째 줄부터 N + 1번째 줄까지, 해당 나무를 수확했을 때 얻을 수 있는 총이익을 표시한다.
	총이익은 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

* 출력  
 첫 번째 줄에 **최댓값**을 출력한다.
-------------------------------------------------------------------

### (2) 문제 풀이 ### 
 1) 301 * 301인 **2차원 배열**을 만들어 총이익을 입력받는다.
 2) 시작점부터 임의의 점까지 **누적합**을 구한다.
 3) 누적합으로부터  시작점이 (a,b)이고 끝점이 (x,y)인 **구간합**을 구한다.<br>
 	**★ 이때 (a,b)부터 (x,y)까지의 구간이 k &#42; k인 정사각형 형태여야 한다. ( k의 범위 : 1 ~ N )** 
	
-----------------------------------------------------------------------

### (3) 소스 코드 ###

* 2차원 배열 map[301][301]에 각각의 '총이익' 입력받고
* **(1,1)부터 (x,y)까지 각각의 '누적합' DP[x][y] 구하기**<br>

```
	for (int x = 1; x <= N; x++) {
		for (int y = 1; y <= N; y++) {
			cin >> map[x][y];
			DP[x][y] = DP[x - 1][y] + DP[x][y - 1] - DP[x - 1][y - 1] + map[x][y];
		}
	}
```

![누적합](https://user-images.githubusercontent.com/83392219/135664693-a162ae69-6536-4ce8-9e65-d706df8cc84d.JPG)


<br><br>

-------------------------------------------------------------------------

* **'누적합'을 이용해서 '구간합' 구하기 ☞ 시작점(a,b) ~ 끝점(x,y)인 '구간합'** 
* #### 구간합을 사용하려면 시작점(a,b)과 끝점(x,y)가 있어야 하고, '정사각형' 모양이 되야하는데 이를 어떻게 줄 것인가? ####
   -->  1 <= k <= N인 변수 k와 for문 도입 :  시작점(a,b)의 행과 열에 for문을 이용해 똑같이 0, 1, 2, 3 ... N 값을 더해 정사각형으로 만들기 (0은 1*1 정사각형 의미)
* 단, (시작점 + K) 즉, (a+k, b+k)가 배열의 범위 (N,N)을 넘지 않도록 범위 검사<br>


* 일단 1 * 1 크기의 맨 처음 값을 최댓값으로 준 뒤 계속 갱신해 나간다. 
```
int MAX = map[1][1];
```	
		

* 모든 경우를 다 탐색하는 완전탐색
* 모든 경우를 하나씩 고려하고, 범위 안에 있을 경우에는 최대값이 되는지 확인 후, 계속해서 최댓값을 갱신해나감
* 빅오 :  O(N<sup>3</sup>)이지만 전체 데이터 N이 300개라서 괜찮다.  (10<sup>6</sup>은 약 1<sub>ms</sub>)
	
```
for (int x = 1; x <= N; x++) {
	for (int y = 1; y <= N; y++) {
		for (int k = 0; k <= N; k++) {
			if (x + k <= N && y + k <= N) {
				int tmp = DP[x + k][y + k] - DP[x - 1][y + k] - DP[x + k][y - 1] + DP[x - 1][y - 1];
				MAX = max(MAX, tmp);	
			}
				
		}
	}
}
```
<br><br>

![구간합](https://user-images.githubusercontent.com/83392219/135664685-f4e2eb2c-4da5-47bd-8f35-c0020048ecd1.JPG)

